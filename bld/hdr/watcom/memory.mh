:segment !CPPMEMORY
/*
 *  memory.h    C library memory manipulation functions
 *
:include crwat.sp
 */
#ifndef _MEMORY_H_INCLUDED
#define _MEMORY_H_INCLUDED

:include readonly.sp

#ifndef _STRING_H_INCLUDED
 #include <string.h>
#endif

#endif
:elsesegment
:: Note that <memory> has nothing to do with <memory.h>. Both targets
:: are being generated from this file because of their common name,
:: not because they represent the same facility.
::
///////////////////////////////////////////////////////////////////////////
// FILE: memory (Utilities for manipulating memory)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This header is part of the C++ standard library. It
//              defines a number of helper templates to simplify the
//              handling of raw memory.
///////////////////////////////////////////////////////////////////////////
#ifndef _MEMORY_INCLUDED
#define _MEMORY_INCLUDED

:include readonly.sp

#ifndef __cplusplus
#error The header memory requires C++
#endif

#ifndef _CSTDDEF_INCLUDED
  #include <cstddef>
#endif

#ifndef _ITERATOR_INCLUDED
  #include <iterator>
#endif

#ifndef _NEW_INCLUDED
  #include <new>
#endif

#define typename

:include throws.sp

template< class Iterator, class Type >
inline void _RawConstruct( Iterator ptr, const Type &value )
{
    typedef typename std::iterator_traits< Iterator >::value_type value_type;
    new ( static_cast< void * >( &*ptr ) ) value_type( value );
}

template< class Iterator >
inline void _RawDestroy( Iterator ptr )
{
    typedef typename std::iterator_traits< Iterator >::value_type value_type;
    ( *ptr ).~value_type( );
}

namespace std {

  template< class Type > class allocator;

  // Allocator specialization for void.
  template< >
  class allocator< void > {
  public:
    typedef void       *pointer;
    typedef const void *const_pointer;
    typedef void        value_type;
  };

  // Default allocator template.
  template< class Type >
  class allocator {
  public:
    typedef       std::size_t    size_type;
    typedef       std::ptrdiff_t difference_type;
    typedef       Type          *pointer;
    typedef const Type          *const_pointer;
    typedef       Type          &reference;
    typedef const Type          &const_reference;
    typedef       Type           value_type;
    // template< class U > struct rebind { typedef allocator< U > other; };

    allocator( )
      { }

    allocator( const allocator & )
      { }

    // template< class U > allocator( const allocator< U > & )

   ~allocator( )
      { }

    pointer address( reference r ) const
      { return( &r ); }

    const_pointer address( const_reference r ) const
      { return( &r ); }

    pointer allocate( size_type n, allocator< void >::const_pointer = 0 )
      { return( reinterpret_cast< Type * >(
                  new unsigned char[ n * sizeof( Type ) ] ) ); }

    void deallocate( pointer p, size_type )
      { delete [] reinterpret_cast< unsigned char * >( p ); }

    size_type max_size( ) const
      { return 0; }  // FIX ME

    void construct( pointer p, const Type &value )
      { new ( ( void * )p ) Type( value ); }

    void destroy( pointer p )
      { ( ( Type * )p )->~Type( ); }
  };

  // Templates for initializing blocks of uninitialized memory.

  template< class ForwardIterator, class Type >
  void uninitialized_fill(
      ForwardIterator first,
      ForwardIterator last,
      const Type &value )
  {
      typedef
        typename iterator_traits< ForwardIterator >::value_type value_type;
      ForwardIterator bookmark( first );

      _WCTRY {
          // Construct copies of value in the raw storage.
          while( first != last ) {
              _RawConstruct( first, value );
              ++first;
          }
      }
      #ifdef _WCHANDLERS
      // If an exception occurs, destroy copies that were made successfully.
      catch( ... ) {
          while( bookmark != first ) {
              _RawDestroy( bookmark );
              ++bookmark;
          }
          throw;
      }
      #endif
  }


  template< class ForwardIterator, class Size, class Type >
  void uninitialized_fill_n(
      ForwardIterator first,
      Size n,
      const Type &value )
  {
      typedef
        typename iterator_traits< ForwardIterator >::value_type value_type;
      ForwardIterator bookmark( first );

      _WCTRY {
          // Construct n copies of value in raw storage.
          while( n-- ) {
              _RawConstruct( first, value );
              ++first;
          }
      }
      #ifdef _WCHANDLERS
      // If an exception occurs, destroy copies that were made successfully.
      catch( ... ) {
          while( bookmark != first ) {
              _RawDestroy( bookmark );
              ++bookmark;
          }
          throw;
      }
      #endif
  }


  template< class InputIterator, class ForwardIterator >
  ForwardIterator uninitialized_copy(
      InputIterator first,
      InputIterator last,
      ForwardIterator dest )
  {
      typedef
        typename iterator_traits< ForwardIterator >::value_type value_type;
      ForwardIterator bookmark( dest );

      _WCTRY {
          // Copy objects from input sequence to raw storage.
          while( first != last ) {
              _RawConstruct( dest, *first );
              ++first;
              ++dest;
          }
          return( dest );
      }
      #ifdef _WCHANDLERS
      // If an exception occurs, destroy copies that were made successfully.
      catch( ... ) {
          while( bookmark != dest ) {
              _RawDestroy( bookmark );
              ++bookmark;
          }
          throw;
      }
      #endif
  }


  // Auto_ptr template.
  template< class Type >
  class auto_ptr {
    // template< class U > struct auto_ptr_ref { };
  public:
    typedef Type element_type;

    explicit auto_ptr( Type *p = 0 ) : ptr( p )
      { }

    auto_ptr( auto_ptr &other ) : ptr( other.release() )
      { }

    // template< class U > auto_ptr( auto_ptr< U > & );

    auto_ptr &operator=( auto_ptr &other )
      { reset( other.release() ); return( *this ); }

    // template< class U > auto_ptr &operator=( auto_ptr< U > & );

   ~auto_ptr( ) _WCTHROWS( )
      { delete ptr; }

    Type &operator*( ) const
      { return( *ptr ); }

    Type *operator->( ) const
      { return( ptr ); }

    Type *get( ) const
      { return( ptr ); }

    Type *release( )
      { Type *tmp = ptr; ptr = 0; return( tmp ); }

    void reset( Type *p = 0 ) _WCTHROWS( )
      { if ( ptr != p ) delete ptr; ptr = p; }

    // auto_ptr( auto_ptr_ref< Type > ) _WCTHROWS( );

    // template< class U > operator auto_ptr_ref< U >( ) _WCTHROWS( );

    // template< class U > operator auto_ptr< U >( ) _WCTHROWS( );

  private:
    Type *ptr;
  };

} // namespace std.

#endif
:endsegment
